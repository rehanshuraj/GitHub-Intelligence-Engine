TASK 1: file and folders structure :-
        backend/
        â”‚
        â”œâ”€â”€ controllers/
        â”‚   â””â”€â”€ analyze.controller.js
        â”‚
        â”œâ”€â”€ graphql/
        â”‚   â””â”€â”€ queries.js
        â”‚
        â”œâ”€â”€ routes/
        â”‚   â””â”€â”€ auth.js
        â”‚
        â”œâ”€â”€ services/
        â”‚   â”œâ”€â”€ github.service.js
        â”‚   â”œâ”€â”€ commit.service.js
        â”‚   â”œâ”€â”€ commitScore.js
        â”‚
        â”œâ”€â”€ utils/
        â”‚   â””â”€â”€ commitClassifier.js
        â”‚
        â”œâ”€â”€ repoFilter.js
        â”‚
        â”œâ”€â”€ .env
        â”œâ”€â”€ server.js
        â””â”€â”€ package.json


        step1: setup server.js
        step2: make routes folder and add routings in auth.js
        step3: graphql/queries.js
        step4: services/  - github.service.js
                        - repoFilter.js
                        - commit.service.js
        step5:  utils/commitClassifier.js
        step6:  services/commitScore.js
        step7:  controllers/analyze.controller.js

explaination for task1:
    -routes/auth.js
       This file handles:
        Logging in with GitHub
        Getting permission
        Returning a safe token to frontend


        1.OAuth
        OAuth is like this:

            â€œHey GitHub, can you allow my app to read this userâ€™s repos?â€
            GitHub: â€œOnly if the user agrees.â€
            User: â€œI agree.â€
            GitHub: â€œOkay, hereâ€™s a key (token). Use it carefully.â€

            That key = access token

         FLOW:
           - User logs in
           - GitHub approves
          -  Backend creates JWT
           - User is sent to frontend with token
           - Frontend stores JWT
           - Frontend sends JWT in API requests

        User clicks login
        â†“
        Backend redirects to GitHub
        â†“
        GitHub authenticates user
        â†“
        GitHub sends code
        â†“
        Backend exchanges code for token
        â†“
        Backend wraps token in JWT
        â†“
        Frontend uses JWT to request analysis

###
STATIC CODE COMPLEXITY USING AST(Abstract Syntax Tree)
We will compute REAL engineering signals:

1ï¸âƒ£ Function length
2ï¸âƒ£ Cyclomatic complexity
3ï¸âƒ£ Nesting depth
4ï¸âƒ£ God functions
5ï¸âƒ£ Maintainability signals

Dependencies :-npm install @babel/parser @babel/traverse fs path
@babel/parser â†’ converts JS â†’ AST
@babel/traverse â†’ walks through AST

files and folders structure 
    services/
    â””â”€â”€ codeAnalysis.service.js FILE â†’ TEXT â†’ AST â†’ FUNCTION NODES â†’ METRICS


    utils/
    â””â”€â”€ complexityCalculator.js
    This file teaches the computer:
    how many decisions exist
    how deep logic is buried
    how large a function is
    whether itâ€™s becoming dangerous

###
Risky Coding Pattern Detector
  Because:
   - Bugs hide in them
    -Security breaches start here
   - Maintenance becomes hell
   - Juniors write them unconsciously
   - Seniors actively avoid the
   - This is engineering maturity, not syntax.

utils/
 â””â”€â”€ riskDetector.js

This file:
    looks at ONE function
    reports risky patterns

###
FULL-EMS (Engineering Maturity Score)
GitHub shows:

stars â­
followers ğŸ‘¥
commits ğŸ“ˆ

But companies want:
Can this person write maintainable code?
Do they refactor or just pile up logic?
Do they write safe, disciplined code?
Are they consistent over time?

So we create EMS = Engineering Maturity Score (0â€“100)
EMS answers:
â€œHow mature is this engineerâ€™s thinking in code?â€
What inputs does EMS need?
    -Commit Quality Score (0â€“20)
    - Code Complexity Metrics
        cyclomatic complexity
        nesting depth
        god functions
    -Risky Coding Patterns
        secrets
        empty catch
        globals
    -Consistency
        steady commits
        no massive spikes
    -Refactor Signals
        refactor commits exist
    EMS is just combining intelligence, not magic.

EMS Philosophy (VERY IMPORTANT)
    We do NOT reward:
    âŒ more commits
    âŒ more repos
    âŒ more LOC
    We reward:
    âœ… discipline
    âœ… simplicity
    âœ… improvement over time
    âœ… safety
    Thatâ€™s why weights matter.
services/
 â””â”€â”€ emsScore.service.js
This file:
    takes all metrics
    normalizes them
    outputs ONE score

Bad engineers:  update
                final
                fix
Good engineers: refactor: simplify auth logic
                test: add edge case for null user


##FLOW OF THE BACKENED
server.js
   â†“
route (/analyze)
   â†“
controller
   â†“
services
   â†“
utils

ğŸ§© CONTROLLER FLOW 
When someone hits:  GET /analyze/:username

The controller does this:
   - Get GitHub token from JWT
    -Fetch repositories
    -Analyze commits
   - Analyze code complexity
   -Detect risks
   -Calculate EMS
   - Send JSON response


NOW NEXT:-

Code analysis (analyzeFile)
Risk detection (detectRisks)

require downloading repo files.
That is the NEXT step.
functionNode comes from parsing real .js files
GitHub ZIP download - best for backened faster and secure 
GitHub Repo
 â†’ Download files
 â†’ Read .js files
 â†’ Parse AST
 â†’ Complexity + Risk
 â†’ EMS
 Dependencies : npm install unzipper
    
When you call: downloadRepo("rehanshu", "AIvora", accessToken)

It:
    Downloads repo as ZIP
    Saves it locally
    Extracts all files
    Returns folder path like: /backend/temp/AIvora/


NOW Reading .js files from the downloaded repo
Add this helper inside
ğŸ“ services/codeAnalysis.service.js

Connecting DOWNLOAD â†’ ANALYSIS (CRITICAL)
Inside
ğŸ“ controllers/analyze.controller.js

## FULL PIPELINE
GitHub API
   â†“
Repo ZIP Download
   â†“
Extract Files
   â†“
Read .js Files
   â†“
AST Parsing
   â†“
Complexity + Risk
   â†“
EMS Score

âœ” GitHub OAuth
âœ” Commit intelligence
âœ” Repo downloading
âœ” Static code analysis
âœ” Risk detection
âœ” EMS calculation